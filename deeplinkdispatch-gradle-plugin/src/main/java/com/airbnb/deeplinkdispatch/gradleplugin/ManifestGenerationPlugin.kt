package com.airbnb.deeplinkdispatch.gradleplugin

import com.android.build.api.artifact.SingleArtifact
import com.android.build.api.variant.AndroidComponentsExtension
import com.android.manifmerger.ManifestMerger2
import com.android.manifmerger.MergingReport
import com.android.utils.StdLogger
import com.google.devtools.ksp.gradle.KspExtension
import com.google.devtools.ksp.gradle.KspGradleSubplugin

import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project


import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import java.io.File

/**
 * For deep links that have activityClasFqn set, the DeepLinkDispatch annotation processor generates
 * an AndroidManifest.xml that contains the intent filters for the deeplinks.
 *
 * This plugin takes the generated manifest and merges it with the merged manifest created by the
 * Android Gradle Plugin.
 *
 * This means that for any deep links that have activityClasFqn set it is not necessary to add the
 * intent filters to the AndroidManifest.xml manually.
 */
class ManifestGenerationPlugin: Plugin<Project> {

    override fun apply(project: Project) {

        // If the KSP plugin was already applied, we need to update the args for the manifest
        // generation.
        if(project.plugins.hasPlugin(KspGradleSubplugin::class.java)) {
            updateKspArgsForManifestGeneration(project)
        }

        // Just in calse listen to when the KSP plugin is applied and update the args for the
        // manifest generation. This can happen if the KSP plugin is applied after this plugin.
        project.plugins.whenPluginAdded {
            when (this) {
                is KspGradleSubplugin -> {
                    updateKspArgsForManifestGeneration(project)
                }
            }
        }

        val androidComponents = project.extensions.getByType(
            AndroidComponentsExtension::class.java
        )
        androidComponents.onVariants { variant ->
            val manifestUpdater = project.tasks.register(
                variant.name + "UpdateManifestIntentFiltersForDeepLinkDispatch",
                UpdateManifestIntentFiltersForDeeplinkDispatchTask::class.java
            ) {
                val generatedManifestFile =
                    File(project.buildDir, "/intermediates/deeplinkdispatch/AndroidManifest.xml")
                if (!generatedManifestFile.exists()) {
                    generatedManifestFile.parentFile.mkdirs()
                    generatedManifestFile.createNewFile()
                }
                manifestIntentFiltersFile.set(
                    project.objects.fileProperty().fileValue(
                        generatedManifestFile
                    )
                )
            }
            variant.artifacts.use(manifestUpdater).wiredWithFiles(
                UpdateManifestIntentFiltersForDeeplinkDispatchTask::mergedManifest,
                UpdateManifestIntentFiltersForDeeplinkDispatchTask::updatedManifest
            ).toTransform(SingleArtifact.MERGED_MANIFEST)
        }
    }

    private fun updateKspArgsForManifestGeneration(project: Project) {
        // This is how we tell the ksp plugin where to write the manifest with the intent
        // filters.
        val kspExtension = project.extensions.getByType(KspExtension::class.java)
        kspExtension.arg(
            "deepLinkManifestGenMetadata.output",
            "${project.buildDir.canonicalPath}/intermediates/deeplinkdispatch/AndroidManifest.xml"
        )

    }


}

abstract class UpdateManifestIntentFiltersForDeeplinkDispatchTask: DefaultTask() {

    @get:InputFile
    abstract val manifestIntentFiltersFile: RegularFileProperty
    @get:InputFile
    abstract val mergedManifest: RegularFileProperty

    @get:OutputFile
    abstract val updatedManifest: RegularFileProperty

    @TaskAction
    fun taskAction() {

        // The input manifest (the merged manifest as created by the Android Gradle Plugin)
        var manifest = mergedManifest.asFile.get()

        // This is using the manifest merger from the Android Gradle Plugin to merge the build
        // system generated manifest with the manifest generated by the DeepLinkDispatch annotation
        // processor, which contains the intent filters.

        val mergeType = if (project.plugins.hasPlugin("com.android.application")) {
            ManifestMerger2.MergeType.APPLICATION
        } else if (project.plugins.hasPlugin("com.android.library")) {
            ManifestMerger2.MergeType.LIBRARY
        } else {
            error("Unsupported plugin type ${this::class.java}. You can only apply this plugin" +
                    " to an Android application or library modules")
        }

        val invoker: ManifestMerger2.Invoker = ManifestMerger2.newMerger(
            manifest,
            StdLogger(StdLogger.Level.VERBOSE),
            mergeType
        )
        val generatedManifestFile = manifestIntentFiltersFile.asFile.get()
        if(generatedManifestFile.exists() && generatedManifestFile.length() > 0) {
            invoker.addFlavorAndBuildTypeManifest(generatedManifestFile)
        }

        val merge = invoker.merge()
        if (merge.result.isSuccess) {
            val mergedDocument = merge.getMergedDocument(MergingReport.MergedManifestKind.MERGED)
            updatedManifest.get().asFile.writeText(mergedDocument)
        } else {
            error("Manifest merge for DeepLinkDispatch failed with error: ${merge.result}.")
        }
    }
}