package com.airbnb.deeplinkdispatch.gradleplugin

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction

/**
 * Task that relocates the KSP-generated assets from the resources directory to a safe location.
 *
 * This task must run after KSP and before any asset merge tasks. It moves the asset
 * files out of the KSP resources directory to prevent them from being included as
 * Java resources when this library is used as a project dependency.
 *
 * The assets are the binary match index files generated by the DeepLinkDispatch processor
 * for KSP-based builds. They will be merged into the final assets via the asset transform task.
 *
 * This is a separate task (rather than a doLast on KSP) because doLast doesn't run when
 * KSP is restored FROM-CACHE. This task will always run after KSP, even if KSP was cached.
 */
abstract class RelocateDeepLinkAssetsTask : DefaultTask() {

    /**
     * The directory where KSP generates the asset files.
     * Path: build/generated/ksp/<variant>/resources/assets/deeplinkdispatch/
     */
    @get:InputFiles
    @get:Optional
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val kspAssetsDir: DirectoryProperty

    /**
     * The safe location where assets will be moved to.
     * Path: build/intermediates/deeplinkdispatch/<variant>/assets/deeplinkdispatch/
     */
    @get:OutputDirectory
    abstract val safeAssetsDir: DirectoryProperty

    init {
        // Force the task to run when the source directory exists with files
        outputs.upToDateWhen {
            val sourceDir = kspAssetsDir.orNull?.asFile
            // Task is only up-to-date if source directory doesn't exist or is empty
            sourceDir == null || !sourceDir.exists() || sourceDir.listFiles()?.isEmpty() != false
        }
    }

    @TaskAction
    fun taskAction() {
        val sourceDir = kspAssetsDir.orNull?.asFile
        val destDir = safeAssetsDir.get().asFile

        if (sourceDir != null && sourceDir.exists() && sourceDir.isDirectory) {
            val files = sourceDir.listFiles() ?: emptyArray()
            if (files.isNotEmpty()) {
                // Ensure destination directory exists
                destDir.mkdirs()

                // Copy all files to safe location
                files.forEach { file ->
                    if (file.isFile) {
                        file.copyTo(destDir.resolve(file.name), overwrite = true)
                    }
                }

                // Delete from KSP resources to prevent Java resource processing
                files.forEach { file ->
                    file.delete()
                }

                // Delete empty parent directories up to but not including "resources"
                var parentDir = sourceDir
                while (parentDir != null &&
                    parentDir.name != "resources" &&
                    parentDir.isDirectory &&
                    parentDir.list()?.isEmpty() == true
                ) {
                    val nextParent = parentDir.parentFile
                    parentDir.delete()
                    parentDir = nextParent
                }
            }
        } else if (destDir.exists() && destDir.listFiles()?.isNotEmpty() == true) {
            // Source doesn't exist but dest does - this can happen on incremental builds
            // where KSP was UP-TO-DATE and we already moved the files previously.
            // The dest files are still valid, so nothing to do.
        }
        // If neither exists, no assets were generated (which is fine for modules without deep links)
    }
}
