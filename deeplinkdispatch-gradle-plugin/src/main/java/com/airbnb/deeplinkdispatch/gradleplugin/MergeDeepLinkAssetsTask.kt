package com.airbnb.deeplinkdispatch.gradleplugin

import com.android.build.api.variant.Variant
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import java.io.File

/**
 * Gradle task that merges KSP-generated assets with AGP's merged assets.
 *
 * This task is wired into AGP's Artifacts API as an ASSETS transformer. It takes
 * the existing assets from AGP and adds the DeepLinkDispatch binary match index
 * files that were generated by KSP and relocated by RelocateDeepLinkAssetsTask.
 *
 * The match index files are placed under assets/deeplinkdispatch/<modulename>.bin
 * and are used by the generated registry classes to load the deep link matching
 * tree at runtime without the overhead of string parsing and encoding.
 */
@CacheableTask
abstract class MergeDeepLinkAssetsTask : DefaultTask() {

    /**
     * The input assets directory from AGP's merged assets.
     */
    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val inputAssets: DirectoryProperty

    /**
     * The directory containing DeepLinkDispatch assets relocated from KSP output.
     * Path: build/intermediates/deeplinkdispatch/<variant>/assets/deeplinkdispatch/
     */
    @get:InputFiles
    @get:Optional
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val additionalAssetsDir: DirectoryProperty

    /**
     * The output assets directory that will replace the merged assets.
     */
    @get:OutputDirectory
    abstract val outputAssets: DirectoryProperty

    @TaskAction
    fun taskAction() {
        val inputDir = inputAssets.get().asFile
        val outputDir = outputAssets.get().asFile
        val additionalDir = additionalAssetsDir.orNull?.asFile

        // Clean output directory
        outputDir.deleteRecursively()
        outputDir.mkdirs()

        // Copy all existing assets from input
        if (inputDir.exists()) {
            inputDir.copyRecursively(outputDir, overwrite = true)
        }

        // Merge DeepLinkDispatch assets if they exist
        if (additionalDir != null && additionalDir.exists() && additionalDir.isDirectory) {
            val files = additionalDir.listFiles() ?: emptyArray()
            if (files.isNotEmpty()) {
                // Create deeplinkdispatch subdirectory in output
                val deeplinkDispatchDir = File(outputDir, "deeplinkdispatch")
                deeplinkDispatchDir.mkdirs()

                // Copy each match index file
                files.forEach { file ->
                    if (file.isFile) {
                        file.copyTo(File(deeplinkDispatchDir, file.name), overwrite = true)
                    }
                }
            }
        }
    }

    companion object {
        internal fun taskName(variant: Variant) =
            "mergeDeepLinkAssets${variant.name.replaceFirstChar { it.uppercase() }}"
    }
}
